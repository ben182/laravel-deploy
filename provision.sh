#!/bin/bash

# Hetzner Ubuntu 24.04 Server Provisioning Script
# Usage: ./provision.sh

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
DEFAULT_USER="deploy"
SSH_PORT="22"
SWAP_SIZE="2G"
FAIL2BAN_MAXRETRY="5"
FAIL2BAN_BANTIME="600"

# Helper functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

show_usage() {
    echo "Hetzner Ubuntu 24.04 Server Provisioning Script"
    echo ""
    echo "Usage: $0"
    echo ""
    echo "This script provisions a fresh Ubuntu 24.04 server with:"
    echo "  - Creates 'deploy' user for deployments"
    echo "  - Installs Docker, Nginx, Certbot"
    echo "  - Configures security (UFW, Fail2ban, SSH hardening)"
    echo "  - Optimizes performance and monitoring"
    echo ""
    echo "Run this script as root on your server."
}

check_root() {
    if [[ $EUID -ne 0 ]]; then
        log_error "This script must be run as root"
        exit 1
    fi
}

check_ubuntu() {
    if ! grep -q "Ubuntu 24.04" /etc/os-release; then
        log_warning "This script is designed for Ubuntu 24.04, but continuing anyway"
    fi
}

update_system() {
    log_info "Updating system packages..."
    apt-get update -y
    apt-get upgrade -y
    apt-get autoremove -y
    apt-get autoclean
    log_success "System updated successfully"
}

install_essential_packages() {
    log_info "Installing essential packages..."
    apt-get install -y \
        curl \
        wget \
        git \
        vim \
        htop \
        ufw \
        fail2ban \
        unattended-upgrades \
        apt-transport-https \
        ca-certificates \
        gnupg \
        lsb-release \
        software-properties-common \
        zip \
        unzip \
        tree \
        net-tools \
        rsync \
        screen \
        tmux \
        build-essential
    log_success "Essential packages installed successfully"
}

create_user() {
    local username=$DEFAULT_USER
    
    log_info "Creating user: $username"
    
    if id "$username" &>/dev/null; then
        log_warning "User $username already exists, skipping creation"
    else
        useradd -m -s /bin/bash "$username"
        usermod -aG sudo "$username"
        log_success "User $username created successfully"
    fi
    
    # Create SSH directory for future key setup
    sudo -u "$username" mkdir -p "/home/$username/.ssh"
    sudo -u "$username" chmod 700 "/home/$username/.ssh"
    
    log_info "SSH directory created. Add your SSH public key to /home/$username/.ssh/authorized_keys"
    log_info "Example: echo 'your-public-key' >> /home/$username/.ssh/authorized_keys"
}

configure_ssh() {
    log_info "Configuring SSH security..."
    
    # Backup original config
    cp /etc/ssh/sshd_config /etc/ssh/sshd_config.backup
    
    # Configure SSH
    cat > /etc/ssh/sshd_config << EOF
# SSH Configuration - Auto-generated by provision script
Port $SSH_PORT
Protocol 2

# Authentication
PermitRootLogin no
PasswordAuthentication no
PubkeyAuthentication yes
AuthorizedKeysFile %h/.ssh/authorized_keys
ChallengeResponseAuthentication no
UsePAM yes

# Security
X11Forwarding no
PrintMotd no
AcceptEnv LANG LC_*
Subsystem sftp /usr/lib/openssh/sftp-server

# Performance
ClientAliveInterval 60
ClientAliveCountMax 3
MaxAuthTries 3
MaxSessions 10
LoginGraceTime 30

# Logging
SyslogFacility AUTH
LogLevel INFO
EOF
    
    systemctl restart sshd
    log_success "SSH configured successfully"
}

setup_firewall() {
    log_info "Configuring UFW firewall..."
    
    ufw --force reset
    ufw default deny incoming
    ufw default allow outgoing
    
    # Allow SSH
    ufw allow $SSH_PORT/tcp
    
    # Allow HTTP/HTTPS
    ufw allow 80/tcp
    ufw allow 443/tcp
    
    # Enable firewall
    ufw --force enable
    
    log_success "Firewall configured successfully"
}

configure_fail2ban() {
    log_info "Configuring Fail2ban..."
    
    cat > /etc/fail2ban/jail.local << EOF
[DEFAULT]
bantime = $FAIL2BAN_BANTIME
findtime = 600
maxretry = $FAIL2BAN_MAXRETRY
backend = systemd

[sshd]
enabled = true
port = $SSH_PORT
filter = sshd
logpath = /var/log/auth.log
maxretry = $FAIL2BAN_MAXRETRY

[nginx-http-auth]
enabled = true
filter = nginx-http-auth
logpath = /var/log/nginx/error.log
maxretry = 5

[nginx-noscript]
enabled = true
filter = nginx-noscript
logpath = /var/log/nginx/access.log
maxretry = 6

[nginx-badbots]
enabled = true
filter = nginx-badbots
logpath = /var/log/nginx/access.log
maxretry = 2

[nginx-noproxy]
enabled = true
filter = nginx-noproxy
logpath = /var/log/nginx/access.log
maxretry = 2
EOF
    
    systemctl enable fail2ban
    systemctl restart fail2ban
    log_success "Fail2ban configured successfully"
}

setup_swap() {
    log_info "Setting up swap file ($SWAP_SIZE)..."
    
    if [[ -f /swapfile ]]; then
        log_warning "Swap file already exists, skipping creation"
        return
    fi
    
    fallocate -l $SWAP_SIZE /swapfile
    chmod 600 /swapfile
    mkswap /swapfile
    swapon /swapfile
    
    # Add to fstab
    if ! grep -q "/swapfile" /etc/fstab; then
        echo "/swapfile none swap sw 0 0" >> /etc/fstab
    fi
    
    # Configure swappiness
    echo "vm.swappiness=10" >> /etc/sysctl.conf
    
    log_success "Swap configured successfully"
}

configure_automatic_updates() {
    log_info "Configuring automatic updates..."
    
    cat > /etc/apt/apt.conf.d/50unattended-upgrades << EOF
Unattended-Upgrade::Allowed-Origins {
    "\${distro_id}:\${distro_codename}";
    "\${distro_id}:\${distro_codename}-security";
    "\${distro_id}ESMApps:\${distro_codename}-apps-security";
    "\${distro_id}ESM:\${distro_codename}-infra-security";
};

Unattended-Upgrade::Package-Blacklist {
};

Unattended-Upgrade::DevRelease "auto";
Unattended-Upgrade::AutoFixInterruptedDpkg "true";
Unattended-Upgrade::MinimalSteps "true";
Unattended-Upgrade::InstallOnShutdown "false";
Unattended-Upgrade::Remove-Unused-Kernel-Packages "true";
Unattended-Upgrade::Remove-New-Unused-Dependencies "true";
Unattended-Upgrade::Remove-Unused-Dependencies "false";
Unattended-Upgrade::Automatic-Reboot "false";
Unattended-Upgrade::Automatic-Reboot-WithUsers "false";
Unattended-Upgrade::Automatic-Reboot-Time "02:00";
Unattended-Upgrade::SyslogEnable "false";
Unattended-Upgrade::SyslogFacility "daemon";
Unattended-Upgrade::OnlyOnACPower "true";
Unattended-Upgrade::Skip-Updates-On-Metered-Connections "true";
Unattended-Upgrade::Verbose "false";
Unattended-Upgrade::Debug "false";
EOF
    
    cat > /etc/apt/apt.conf.d/20auto-upgrades << EOF
APT::Periodic::Update-Package-Lists "1";
APT::Periodic::Download-Upgradeable-Packages "1";
APT::Periodic::AutocleanInterval "7";
APT::Periodic::Unattended-Upgrade "1";
EOF
    
    systemctl enable unattended-upgrades
    systemctl start unattended-upgrades
    log_success "Automatic updates configured successfully"
}

install_docker() {
    log_info "Installing Docker..."
    
    # Add Docker's official GPG key
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
    
    # Add Docker repository
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
    
    # Install Docker
    apt-get update -y
    apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
    
    # Start and enable Docker
    systemctl start docker
    systemctl enable docker
    
    # Add user to docker group
    usermod -aG docker "$DEFAULT_USER"
    
    log_success "Docker installed successfully"
}

install_nginx() {
    log_info "Installing Nginx..."
    
    apt-get install -y nginx
    
    # Configure Nginx
    cat > /etc/nginx/nginx.conf << 'EOF'
user www-data;
worker_processes auto;
pid /run/nginx.pid;
include /etc/nginx/modules-enabled/*.conf;

events {
    worker_connections 1024;
    use epoll;
    multi_accept on;
}

http {
    # Basic Settings
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    server_tokens off;
    client_max_body_size 50M;
    
    # MIME
    include /etc/nginx/mime.types;
    default_type application/octet-stream;
    
    # Logging
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';
    
    access_log /var/log/nginx/access.log main;
    error_log /var/log/nginx/error.log;
    
    # Gzip Settings
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/json
        application/javascript
        application/xml+rss
        application/atom+xml
        image/svg+xml;
    
    # Security Headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    
    # Rate Limiting
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
    limit_req_zone $binary_remote_addr zone=login:10m rate=1r/s;
    
    # Virtual Host Configs
    include /etc/nginx/conf.d/*.conf;
    include /etc/nginx/sites-enabled/*;
}
EOF
    
    # Remove default site
    rm -f /etc/nginx/sites-enabled/default
    
    # Create default catch-all site
    cat > /etc/nginx/sites-available/default << 'EOF'
server {
    listen 80 default_server;
    listen [::]:80 default_server;
    server_name _;
    
    location / {
        return 444;
    }
}
EOF
    
    ln -sf /etc/nginx/sites-available/default /etc/nginx/sites-enabled/default
    
    # Test and start Nginx
    nginx -t
    systemctl start nginx
    systemctl enable nginx
    
    log_success "Nginx installed and configured successfully"
}

install_certbot() {
    log_info "Installing Certbot..."
    
    apt-get install -y certbot python3-certbot-nginx
    
    # Create renewal hook
    cat > /etc/letsencrypt/renewal-hooks/deploy/nginx-reload << 'EOF'
#!/bin/bash
systemctl reload nginx
EOF
    
    chmod +x /etc/letsencrypt/renewal-hooks/deploy/nginx-reload
    
    log_success "Certbot installed successfully"
}

optimize_performance() {
    log_info "Optimizing system performance..."
    
    # Kernel parameters
    cat >> /etc/sysctl.conf << 'EOF'

# Network Performance
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
net.ipv4.tcp_rmem = 4096 87380 16777216
net.ipv4.tcp_wmem = 4096 65536 16777216
net.ipv4.tcp_congestion_control = bbr
net.core.default_qdisc = fq

# Security
net.ipv4.tcp_syncookies = 1
net.ipv4.ip_forward = 0
net.ipv4.conf.all.send_redirects = 0
net.ipv4.conf.default.send_redirects = 0
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.conf.default.accept_redirects = 0
net.ipv4.conf.all.secure_redirects = 0
net.ipv4.conf.default.secure_redirects = 0

# File system
fs.file-max = 2097152
fs.nr_open = 1048576
EOF
    
    # Apply sysctl settings
    sysctl -p
    
    # Increase limits
    cat >> /etc/security/limits.conf << 'EOF'

# Increased limits for better performance
* soft nofile 65536
* hard nofile 65536
* soft nproc 65536
* hard nproc 65536
EOF
    
    log_success "Performance optimizations applied"
}

setup_monitoring() {
    log_info "Setting up basic monitoring..."
    
    # Create monitoring script
    cat > /usr/local/bin/system-monitor.sh << 'EOF'
#!/bin/bash

# System monitoring script
LOG_FILE="/var/log/system-monitor.log"
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

# Check disk space
DISK_USAGE=$(df -h / | awk 'NR==2 {print $5}' | sed 's/%//')
if [ $DISK_USAGE -gt 80 ]; then
    echo "[$TIMESTAMP] WARNING: Disk usage is ${DISK_USAGE}%" >> $LOG_FILE
fi

# Check memory usage
MEM_USAGE=$(free | grep Mem | awk '{printf "%.0f", $3/$2 * 100.0}')
if [ $MEM_USAGE -gt 80 ]; then
    echo "[$TIMESTAMP] WARNING: Memory usage is ${MEM_USAGE}%" >> $LOG_FILE
fi

# Check load average
LOAD_AVG=$(uptime | awk '{print $10}' | sed 's/,//')
if (( $(echo "$LOAD_AVG > 2.0" | bc -l) )); then
    echo "[$TIMESTAMP] WARNING: Load average is $LOAD_AVG" >> $LOG_FILE
fi
EOF
    
    chmod +x /usr/local/bin/system-monitor.sh
    
    # Add to crontab
    (crontab -l 2>/dev/null; echo "*/5 * * * * /usr/local/bin/system-monitor.sh") | crontab -
    
    log_success "Basic monitoring configured"
}

create_deployment_structure() {
    local username=$DEFAULT_USER
    
    log_info "Creating deployment directory structure..."
    
    # Create directories
    sudo -u "$username" mkdir -p "/home/$username/projects"
    sudo -u "$username" mkdir -p "/home/$username/backups"
    sudo -u "$username" mkdir -p "/home/$username/logs"
    sudo -u "$username" mkdir -p "/home/$username/scripts"
    
    # Create deployment info file
    cat > "/home/$username/server-info.txt" << EOF
Server Information
==================
Provisioned: $(date)
OS: $(lsb_release -d | cut -f2)
Kernel: $(uname -r)
User: $username
SSH Port: $SSH_PORT
Docker: $(docker --version)
Nginx: $(nginx -v 2>&1)

Directories:
- Projects: /home/$username/projects
- Backups: /home/$username/backups
- Logs: /home/$username/logs
- Scripts: /home/$username/scripts

Services:
- Docker: systemctl status docker
- Nginx: systemctl status nginx
- Fail2ban: systemctl status fail2ban
- UFW: ufw status

Monitoring:
- System monitor: /usr/local/bin/system-monitor.sh
- Log file: /var/log/system-monitor.log

Next Steps:
1. Add your SSH public key to /home/$username/.ssh/authorized_keys
2. Create deploy.yml in your Laravel projects
3. Run ./deploy.sh from your project directory
EOF
    
    chown "$username:$username" "/home/$username/server-info.txt"
    
    log_success "Deployment structure created"
}

main() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        show_usage
        exit 0
    fi
    
    log_info "Starting server provisioning..."
    log_info "Target user: $DEFAULT_USER"
    
    check_root
    check_ubuntu
    
    # Core system setup
    update_system
    install_essential_packages
    create_user
    configure_ssh
    setup_firewall
    configure_fail2ban
    setup_swap
    configure_automatic_updates
    
    # Application stack
    install_docker
    install_nginx
    install_certbot
    
    # Optimization and monitoring
    optimize_performance
    setup_monitoring
    create_deployment_structure
    
    log_success "Server provisioning completed successfully!"
    log_info "Server is ready for deployment"
    log_info "Next steps:"
    log_info "1. Add your SSH public key to /home/$DEFAULT_USER/.ssh/authorized_keys"
    log_info "2. Create deploy.yml in your Laravel projects"
    log_info "3. Run ./deploy.sh from your project directory"
    log_info "4. Check server-info.txt for important information"
}

main "$@"